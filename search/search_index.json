{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Writing about the real-world challenges of building production systems at scale. Distributed systems, authentication patterns, protocol design, and the often uncomfortable gap between elegant theory and operational reality.</p> <p>When official implementations can't follow best practices, when OAuth breaks in enterprise networks, when \"simple\" protocols meet complex organizations\u2014these are the problems worth exploring.</p>"},{"location":"about/","title":"About","text":"<p>Staff Engineer at Mozilla.ai, with extensive experience in distributed systems, authentication, platform engineering, and enterprise architecture.</p>"},{"location":"about/#background","title":"Background","text":"<p>My career has focused on building infrastructure and tooling that enables engineering teams to ship software faster and more reliably, with particular emphasis on authentication patterns, API design, microservices architecture, and platform engineering.</p>"},{"location":"about/#current","title":"Current","text":"<p>Mozilla.ai - Staff Engineer (2024-Present) Building trustworthy AI infrastructure. Creator of mcpd, a tool for managing MCP servers across environments\u2014bridging the gap between \"works on my laptop\" and production-ready deployments in real organizations.</p>"},{"location":"about/#previous-experience","title":"Previous Experience","text":"<p>HashiCorp (2021-2024) Vault Engineering team, working on enterprise secrets management for tier-0 financial institutions. Led initiatives around audit system enhancements, filtering and redaction capabilities, and data-driven quality improvements.</p> <p>NatWest Group (2015-2021) Principal Engineer role focusing on platform engineering and developer experience. Led enterprise tooling initiatives enabling self-service automation across the bank, reducing time-to-production while maintaining governance. Designed and delivered REST-based microservices, event-driven architectures, and integration with cloud platforms (AWS, PCF, HashiCorp Vault).</p> <p>Sage (2019) Technical Architect for Sage People Payroll. End-to-end ownership of technical solution design, including serverless AWS architecture (Lambda, SQS, DynamoDB, Fargate) integrated with Salesforce.</p> <p>Earlier roles include Thomson Reuters, and various consulting positions focused on infrastructure, messaging systems, and enterprise application development.</p> <p>This blog explores the gap between theoretical elegance and operational reality in production systems.</p>"},{"location":"about/#connect","title":"Connect","text":"<ul> <li> github.com/peteski22</li> <li> linkedin.com/in/peter-d-wilson</li> <li> @peteski22.bsky.social</li> <li> @peteski22@mastodon.social</li> </ul>"},{"location":"blog/posts/mcp-identity-crisis/","title":"MCP's Identity Crisis: When Security Theatre Meets Enterprise Reality","text":"<p>The Model Context Protocol (MCP) promises to be the \"USB-C\" of LLM integrations; simple, universal, and \"extremely easy to build.\" Yet a fundamental disconnect exists between its security guidance and how authentication works in production systems. This isn't just a theoretical concern; it's creating an ecosystem where even official implementations can't follow the stated best practices.</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-architectural-context","title":"The Architectural Context","text":"<p>MCP positions itself as a lightweight protocol for connecting LLMs to external systems. The stated design principles emphasise:</p> <ul> <li>\"Extremely easy to build\" - Developers should focus on their core product</li> <li>\"Simple interfaces\" with \"minimal implementation overhead\"</li> <li>Universal connectivity - The USB-C analogy</li> </ul> <p>These are excellent principles. The protocol itself elegantly achieves them, except when it comes to authentication.</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-current-state-a-tale-of-two-patterns","title":"The Current State: A Tale of Two Patterns","text":"<p>The MCP specification (version 2025-06-18) provides no standard mechanism for upstream authentication. This silence, combined with security guidance that explicitly forbids token passthrough, has created a predictable outcome.</p>"},{"location":"blog/posts/mcp-identity-crisis/#whats-actually-happening-in-production","title":"What's Actually Happening in Production","text":"<p>Let's examine the official MCP implementations:</p> <p>Grafana's MCP Server:</p> <pre><code>{\n  \"env\": {\n    \"GRAFANA_SERVICE_ACCOUNT_TOKEN\": \"&lt;your service account token&gt;\"\n  }\n}\n</code></pre> <p>GitHub's MCP Server:</p> <pre><code>{\n  \"env\": {\n    \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"${input:github_token}\"\n  }\n}\n</code></pre> <p>Stripe's MCP Server:</p> <pre><code>npx @stripe/mcp --api-key=YOUR_STRIPE_SECRET_KEY\n</code></pre> <p>Each injects credentials at instance startup, creating a 1:1 binding between process and identity. This pattern, whilst simple to implement; fundamentally prevents multi-tenancy and contradicts modern cloud-native principles.</p>"},{"location":"blog/posts/mcp-identity-crisis/#why-this-pattern-dominates","title":"Why This Pattern Dominates","text":"<p>These teams aren't taking shortcuts. They're responding rationally to constraints:</p> <ol> <li>No standard exists for propagating user identity to upstream services</li> <li>Token passthrough is explicitly forbidden in security guidance</li> <li>The emerging alternative requires implementing OAuth in every server</li> </ol> <p>The result? Everyone defaults to the simplest working solution: static credentials per instance.</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-enterprise-authentication-landscape","title":"The Enterprise Authentication Landscape","text":"<p>To understand why this matters, let's examine how authentication actually works in enterprise environments:</p> <pre><code>flowchart TD\n    subgraph UserZone[\"User Network Zone\"]\n        User[\"End User\"]\n    end\n\n    subgraph AppTier[\"Application Tier\"]\n        AIZone[\"AI App + MCP Client\"]\n        EntIdP[\"Enterprise Identity Platform\"]\n    end\n\n    subgraph ControlledZone[\"Controlled Egress Zone\"]\n        StripeMCP[\"Stripe MCP Server\"]\n    end\n\n    subgraph Internet[\"External / Internet\"]\n        StripeOAuth[\"Stripe OAuth\n        connect.stripe.com\"]\n        StripeAPI[\"Stripe API\n        api.stripe.com\"]\n    end\n\n    User --&gt;|HTTPS| AIZone\n    User -.-&gt;|Blocked: Direct access| StripeMCP\n    User -.-&gt;|Blocked: Cannot grant consent| StripeOAuth\n\n    AIZone --&gt;|MCP Protocol| StripeMCP\n    EntIdP &lt;--&gt;|OAuth flows| StripeOAuth\n\n    StripeMCP --&gt;|Allowed egress| StripeAPI\n    StripeMCP -.-&gt;|Blocked: Cannot complete OAuth flow| StripeOAuth\n\n    StripeAPI --&gt;|Requires OAuth token| StripeOAuth\n\n    style UserZone fill:#fef,stroke:#c9c,stroke-width:3px\n    style AppTier fill:#efe,stroke:#6a6,stroke-width:3px\n    style ControlledZone fill:#ffe,stroke:#fa0,stroke-width:3px\n    style Internet fill:#fee,stroke:#f66,stroke-width:3px\n\n    linkStyle 1,2,6 stroke:#f00,stroke-width:2px\n</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom  Enterprise network architecture showing OAuth authentication barriers in MCP deployments. <p>Key characteristics:</p> <ul> <li>Centralised token acquisition: One system handles OAuth complexity</li> <li>Token propagation: Internal services receive pre-acquired tokens</li> <li>Network isolation: Internal services AND users often can't reach external OAuth providers</li> <li>Audit trails: Maintained at both identity and service layers</li> </ul> <p>This isn't exotic; it's how AWS IAM, Google Cloud IAP, Azure AD, and virtually every enterprise identity system works.</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-emerging-direction-url-mode-elicitation","title":"The Emerging Direction: URL Mode Elicitation","text":"<p>Recent developments (PR #887, merged into 'draft' spec) introduce URL mode elicitation as a proposed approach:</p> <pre><code>// Server rejects caller's token and returns:\n{\n  elicitationId: \"abc123\",\n  loginUrl: \"https://provider.com/oauth/authorize\"\n}\n// Server must then handle OAuth redirect...\n</code></pre> <p>Whilst this could work for interactive, browser-based scenarios where you have control and network access, it presents significant challenges:</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-non-interactive-problem","title":"The Non-Interactive Problem","text":"<p>Many MCP use cases are autonomous:</p> <ul> <li>CI/CD pipelines triggering on commits</li> <li>Scheduled data synchronisation jobs</li> <li>Background analysis tasks</li> <li>Agent-to-agent communication</li> </ul> <p>None of these can \"open a browser\" for authentication.</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-network-topology-challenge","title":"The Network Topology Challenge","text":"<p>Enterprise networks typically isolate both internal services and users:</p> <pre><code>internal_environment:\n  services:\n    internet_access: false  # Security requirement\n    oauth_endpoints: blocked\n  users:\n    external_sites: restricted  # Often blocked by policy\n    approved_domains: limited\n</code></pre> <p>Requiring OAuth flows at the MCP server level breaks this model.</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-complexity-multiplication","title":"The Complexity Multiplication","text":"<p>If this pattern becomes standard, every MCP server would need to:</p> <ul> <li>Implement OAuth client logic</li> <li>Manage HTTPS endpoints for callbacks</li> <li>Handle state correlation and PKCE</li> <li>Implement token refresh logic</li> <li>Ensure security compliance (CSRF protection, secure storage)</li> <li>Meet regulatory requirements (data residency, audit logging)</li> </ul> <p>This isn't just about OAuth; it's about each server becoming responsible for security, storage, compliance, and identity management. The \"extremely easy to build\" principle becomes \"implement a complete identity system in every server.\"</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-pattern-of-dismissal","title":"The Pattern of Dismissal","text":"<p>This isn't the first time these concerns have been raised. The GitHub discussions are littered with proposals that identified and tried to solve this exact problem:</p> <ul> <li> <p>Discussion #193 proposed multi-tenant client support, noting the inefficiency of spinning up separate processes per user. The response? \"Create unique instances of MCP servers.\" </p> </li> <li> <p>Discussion #234 (by @wdawson) proposed exactly what enterprises need: passing user tokens at the tool level to enable multi-user scenarios. It was closed after URL mode was merged, despite URL mode not addressing the core concerns.</p> </li> <li> <p>Issue #195 suggested using standard WWW-Authenticate headers and allowing clients to pass tokens directly. Sixteen developers agreed. No action taken.</p> </li> <li> <p>Discussion #804 proposed a gateway-based model that would work with enterprise architectures. Still under discussion, likely to be superseded by URL mode.</p> </li> </ul> <p>Even a collaborator (@pwwpche) acknowledged the reality: </p> <p>\"An OAuth based MCP Server is a bit too heavy... enterprises would find it hard to implement an extra OAuth layer.\"</p> <p>The community has repeatedly identified the problem. The solutions have been proposed. But the dogmatic rejection of token passthrough means they can't be considered.</p>"},{"location":"blog/posts/mcp-identity-crisis/#examining-the-security-rationale","title":"Examining the Security Rationale","text":"<p>The MCP security guidance presents concerns about token handling. However, there's a disconnect between identified risks and proposed solutions.</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-validated-passthrough-pattern","title":"The Validated Passthrough Pattern","text":"<p>Consider how API gateways, service meshes, and identity-aware proxies work:</p> <pre><code>def handle_request(request, token):\n    # Validate token properties\n    claims = validate_token(token, \n        expected_issuer=\"corp.identity.provider\",\n        expected_audience=\"upstream.api\",\n        check_expiry=True\n    )\n\n    # Forward validated token to upstream\n    upstream_response = call_upstream_api(\n        request=request,\n        auth_header=f\"Bearer {token}\"\n    )\n\n    return upstream_response\n</code></pre> <p>This pattern, validated passthrough; is industry standard. It appears in:</p> <ul> <li>AWS API Gateway</li> <li>Google Cloud Endpoints</li> <li>Azure API Management</li> <li>Kong, Traefik, Envoy</li> <li>Every major service mesh</li> </ul> <p>The security comes from validation, not from preventing passthrough.</p>"},{"location":"blog/posts/mcp-identity-crisis/#trust-boundaries-and-reality","title":"Trust Boundaries and Reality","text":"<p>The current guidance suggests MCP servers can't be trusted with tokens, yet consider the trust already placed in the system: </p> <p>MCP Clients (typically part of the AI application's infrastructure): </p> <ul> <li>Handle all user prompts before forwarding</li> <li>Orchestrate tool calls with sensitive parameters - Receive and process all responses </li> <li>Are trusted as part of the host application's security boundary </li> </ul> <p>MCP Servers:</p> <ul> <li>Process those same prompts via tool calls</li> <li>Execute operations with user data</li> <li>Return results containing confidential information </li> </ul> <p>Both clients and servers must be equally trusted with data. If we trust them with user information, why not with scoped, time-limited tokens meant for upstream APIs?</p>"},{"location":"blog/posts/mcp-identity-crisis/#a-pragmatic-path-forward","title":"A Pragmatic Path Forward","text":"<p>Rather than forcing every MCP server to become an OAuth client, consider standardising identity propagation:</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-conceptual-approach","title":"The Conceptual Approach","text":"<p>The solution involves adding an optional <code>upstream_identity</code> field to MCP requests:</p> <pre><code>export interface UpstreamIdentityPayload {\n  type: string;        // \"bearer\", \"basic\", etc. (RFC 7235)\n  token: string;       // The actual credential\n  [key: string]: unknown;  // Extensible for additional context\n}\n\nexport interface RequestParams {\n  // Existing fields...\n\n  /**\n   * Optional, per-request credentials for upstream APIs.\n   * This field provides a standard mechanism for Identity Propagation.\n   * The server simply validates and forwards to the upstream API.\n   */\n  upstream_identity?: UpstreamIdentityPayload;\n}\n</code></pre> <p>This approach:</p> <ul> <li>Preserves simplicity: Servers just validate and forward</li> <li>Enables multi-tenancy: One instance, multiple users</li> <li>Aligns with enterprise patterns: Tokens from central identity</li> <li>Supports all environments: Works without browsers or internet</li> <li>Maintains security: Full validation without OAuth complexity</li> </ul> <p>(A detailed technical proposal explores the complete specification, including session-level patterns and implementation guidance.)</p>"},{"location":"blog/posts/mcp-identity-crisis/#the-broader-pattern","title":"The Broader Pattern","text":"<p>This situation reflects a recurring challenge in protocol design: the tension between theoretical purity and operational reality.</p> <p>MCP's core protocol succeeds because it embraces simplicity. The authentication challenges arise where that principle gives way to prescriptive security guidance that doesn't align with how systems actually work.</p> <p>When official implementations unanimously diverge from stated best practices, it suggests the practices\u2014not the implementations\u2014need reconsideration.</p>"},{"location":"blog/posts/mcp-identity-crisis/#moving-forward","title":"Moving Forward","text":"<p>MCP has tremendous potential to standardise LLM-to-system integration. The protocol foundation is solid. The tools system is well-designed. But authentication needs pragmatic solutions that acknowledge:</p> <ol> <li>Enterprise networks have established patterns for identity propagation</li> <li>Multi-tenancy requires identity at the request level, not instance level</li> <li>Simplicity means not reimplementing OAuth in every server</li> <li>Security comes from proper validation, not architectural constraints</li> </ol>"},{"location":"blog/posts/mcp-identity-crisis/#a-question-worth-answering","title":"A Question Worth Answering","text":"<p>If MCP servers are trusted with user data but not with bearer tokens, what threat model justifies this distinction?</p> <p>And if the answer is \"defence in depth\"\u2014shouldn't we apply that principle by enabling secure patterns that people will actually use, rather than forcing complex ones they'll work around?</p> <p>The author is a Staff Engineer at Mozilla.ai, creator of mcpd, with extensive experience in enterprise authentication systems including work at HashiCorp on Vault and major financial institutions. This analysis is based on public specifications, official implementations, and established industry patterns.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/","title":"MCP's Identity Crisis: When Security Theatre Meets Enterprise Reality","text":"<p>The Model Context Protocol (MCP) promises to be the \"USB-C\" of LLM integrations; simple, universal, and \"extremely easy to build.\" Yet a fundamental disconnect exists between its security guidance and how authentication works in production systems. This isn't just a theoretical concern; it's creating an ecosystem where even official implementations can't follow the stated best practices.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-architectural-context","title":"The Architectural Context","text":"<p>MCP positions itself as a lightweight protocol for connecting LLMs to external systems. The stated design principles emphasise:</p> <ul> <li>\"Extremely easy to build\" - Developers should focus on their core product</li> <li>\"Simple interfaces\" with \"minimal implementation overhead\"</li> <li>Universal connectivity - The USB-C analogy</li> </ul> <p>These are excellent principles. The protocol itself elegantly achieves them, except when it comes to authentication.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-current-state-a-tale-of-two-patterns","title":"The Current State: A Tale of Two Patterns","text":"<p>The MCP specification (version 2025-06-18) provides no standard mechanism for upstream authentication. This silence, combined with security guidance that explicitly forbids token passthrough, has created a predictable outcome.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#whats-actually-happening-in-production","title":"What's Actually Happening in Production","text":"<p>Let's examine the official MCP implementations:</p> <p>Grafana's MCP Server:</p> <pre><code>{\n  \"env\": {\n    \"GRAFANA_SERVICE_ACCOUNT_TOKEN\": \"&lt;your service account token&gt;\"\n  }\n}\n</code></pre> <p>GitHub's MCP Server:</p> <pre><code>{\n  \"env\": {\n    \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"${input:github_token}\"\n  }\n}\n</code></pre> <p>Stripe's MCP Server:</p> <pre><code>npx @stripe/mcp --api-key=YOUR_STRIPE_SECRET_KEY\n</code></pre> <p>Each injects credentials at instance startup, creating a 1:1 binding between process and identity. This pattern, whilst simple to implement; fundamentally prevents multi-tenancy and contradicts modern cloud-native principles.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#why-this-pattern-dominates","title":"Why This Pattern Dominates","text":"<p>These teams aren't taking shortcuts. They're responding rationally to constraints:</p> <ol> <li>No standard exists for propagating user identity to upstream services</li> <li>Token passthrough is explicitly forbidden in security guidance</li> <li>The emerging alternative requires implementing OAuth in every server</li> </ol> <p>The result? Everyone defaults to the simplest working solution: static credentials per instance.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-enterprise-authentication-landscape","title":"The Enterprise Authentication Landscape","text":"<p>To understand why this matters, let's examine how authentication actually works in enterprise environments:</p> <pre><code>flowchart TD\n    subgraph UserZone[\"User Network Zone\"]\n        User[\"End User\"]\n    end\n\n    subgraph AppTier[\"Application Tier\"]\n        AIZone[\"AI App + MCP Client\"]\n        EntIdP[\"Enterprise Identity Platform\"]\n    end\n\n    subgraph ControlledZone[\"Controlled Egress Zone\"]\n        StripeMCP[\"Stripe MCP Server\"]\n    end\n\n    subgraph Internet[\"External / Internet\"]\n        StripeOAuth[\"Stripe OAuth\n        connect.stripe.com\"]\n        StripeAPI[\"Stripe API\n        api.stripe.com\"]\n    end\n\n    User --&gt;|HTTPS| AIZone\n    User -.-&gt;|Blocked: Direct access| StripeMCP\n    User -.-&gt;|Blocked: Cannot grant consent| StripeOAuth\n\n    AIZone --&gt;|MCP Protocol| StripeMCP\n    EntIdP &lt;--&gt;|OAuth flows| StripeOAuth\n\n    StripeMCP --&gt;|Allowed egress| StripeAPI\n    StripeMCP -.-&gt;|Blocked: Cannot complete OAuth flow| StripeOAuth\n\n    StripeAPI --&gt;|Requires OAuth token| StripeOAuth\n\n    style UserZone fill:#fef,stroke:#c9c,stroke-width:3px\n    style AppTier fill:#efe,stroke:#6a6,stroke-width:3px\n    style ControlledZone fill:#ffe,stroke:#fa0,stroke-width:3px\n    style Internet fill:#fee,stroke:#f66,stroke-width:3px\n\n    linkStyle 1,2,6 stroke:#f00,stroke-width:2px\n</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom  Enterprise network architecture showing OAuth authentication barriers in MCP deployments. <p>Key characteristics:</p> <ul> <li>Centralised token acquisition: One system handles OAuth complexity</li> <li>Token propagation: Internal services receive pre-acquired tokens</li> <li>Network isolation: Internal services AND users often can't reach external OAuth providers</li> <li>Audit trails: Maintained at both identity and service layers</li> </ul> <p>This isn't exotic; it's how AWS IAM, Google Cloud IAP, Azure AD, and virtually every enterprise identity system works.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-emerging-direction-url-mode-elicitation","title":"The Emerging Direction: URL Mode Elicitation","text":"<p>Recent developments (PR #887, merged into 'draft' spec) introduce URL mode elicitation as a proposed approach:</p> <pre><code>// Server rejects caller's token and returns:\n{\n  elicitationId: \"abc123\",\n  loginUrl: \"https://provider.com/oauth/authorize\"\n}\n// Server must then handle OAuth redirect...\n</code></pre> <p>Whilst this could work for interactive, browser-based scenarios where you have control and network access, it presents significant challenges:</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-non-interactive-problem","title":"The Non-Interactive Problem","text":"<p>Many MCP use cases are autonomous:</p> <ul> <li>CI/CD pipelines triggering on commits</li> <li>Scheduled data synchronisation jobs</li> <li>Background analysis tasks</li> <li>Agent-to-agent communication</li> </ul> <p>None of these can \"open a browser\" for authentication.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-network-topology-challenge","title":"The Network Topology Challenge","text":"<p>Enterprise networks typically isolate both internal services and users:</p> <pre><code>internal_environment:\n  services:\n    internet_access: false  # Security requirement\n    oauth_endpoints: blocked\n  users:\n    external_sites: restricted  # Often blocked by policy\n    approved_domains: limited\n</code></pre> <p>Requiring OAuth flows at the MCP server level breaks this model.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-complexity-multiplication","title":"The Complexity Multiplication","text":"<p>If this pattern becomes standard, every MCP server would need to:</p> <ul> <li>Implement OAuth client logic</li> <li>Manage HTTPS endpoints for callbacks</li> <li>Handle state correlation and PKCE</li> <li>Implement token refresh logic</li> <li>Ensure security compliance (CSRF protection, secure storage)</li> <li>Meet regulatory requirements (data residency, audit logging)</li> </ul> <p>This isn't just about OAuth; it's about each server becoming responsible for security, storage, compliance, and identity management. The \"extremely easy to build\" principle becomes \"implement a complete identity system in every server.\"</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-pattern-of-dismissal","title":"The Pattern of Dismissal","text":"<p>This isn't the first time these concerns have been raised. The GitHub discussions are littered with proposals that identified and tried to solve this exact problem:</p> <ul> <li> <p>Discussion #193 proposed multi-tenant client support, noting the inefficiency of spinning up separate processes per user. The response? \"Create unique instances of MCP servers.\" </p> </li> <li> <p>Discussion #234 (by @wdawson) proposed exactly what enterprises need: passing user tokens at the tool level to enable multi-user scenarios. It was closed after URL mode was merged, despite URL mode not addressing the core concerns.</p> </li> <li> <p>Issue #195 suggested using standard WWW-Authenticate headers and allowing clients to pass tokens directly. Sixteen developers agreed. No action taken.</p> </li> <li> <p>Discussion #804 proposed a gateway-based model that would work with enterprise architectures. Still under discussion, likely to be superseded by URL mode.</p> </li> </ul> <p>Even a collaborator (@pwwpche) acknowledged the reality: </p> <p>\"An OAuth based MCP Server is a bit too heavy... enterprises would find it hard to implement an extra OAuth layer.\"</p> <p>The community has repeatedly identified the problem. The solutions have been proposed. But the dogmatic rejection of token passthrough means they can't be considered.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#examining-the-security-rationale","title":"Examining the Security Rationale","text":"<p>The MCP security guidance presents concerns about token handling. However, there's a disconnect between identified risks and proposed solutions.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-validated-passthrough-pattern","title":"The Validated Passthrough Pattern","text":"<p>Consider how API gateways, service meshes, and identity-aware proxies work:</p> <pre><code>def handle_request(request, token):\n    # Validate token properties\n    claims = validate_token(token, \n        expected_issuer=\"corp.identity.provider\",\n        expected_audience=\"upstream.api\",\n        check_expiry=True\n    )\n\n    # Forward validated token to upstream\n    upstream_response = call_upstream_api(\n        request=request,\n        auth_header=f\"Bearer {token}\"\n    )\n\n    return upstream_response\n</code></pre> <p>This pattern, validated passthrough; is industry standard. It appears in:</p> <ul> <li>AWS API Gateway</li> <li>Google Cloud Endpoints</li> <li>Azure API Management</li> <li>Kong, Traefik, Envoy</li> <li>Every major service mesh</li> </ul> <p>The security comes from validation, not from preventing passthrough.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#trust-boundaries-and-reality","title":"Trust Boundaries and Reality","text":"<p>The current guidance suggests MCP servers can't be trusted with tokens, yet consider the trust already placed in the system: </p> <p>MCP Clients (typically part of the AI application's infrastructure): </p> <ul> <li>Handle all user prompts before forwarding</li> <li>Orchestrate tool calls with sensitive parameters - Receive and process all responses </li> <li>Are trusted as part of the host application's security boundary </li> </ul> <p>MCP Servers:</p> <ul> <li>Process those same prompts via tool calls</li> <li>Execute operations with user data</li> <li>Return results containing confidential information </li> </ul> <p>Both clients and servers must be equally trusted with data. If we trust them with user information, why not with scoped, time-limited tokens meant for upstream APIs?</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#a-pragmatic-path-forward","title":"A Pragmatic Path Forward","text":"<p>Rather than forcing every MCP server to become an OAuth client, consider standardising identity propagation:</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-conceptual-approach","title":"The Conceptual Approach","text":"<p>The solution involves adding an optional <code>upstream_identity</code> field to MCP requests:</p> <pre><code>export interface UpstreamIdentityPayload {\n  type: string;        // \"bearer\", \"basic\", etc. (RFC 7235)\n  token: string;       // The actual credential\n  [key: string]: unknown;  // Extensible for additional context\n}\n\nexport interface RequestParams {\n  // Existing fields...\n\n  /**\n   * Optional, per-request credentials for upstream APIs.\n   * This field provides a standard mechanism for Identity Propagation.\n   * The server simply validates and forwards to the upstream API.\n   */\n  upstream_identity?: UpstreamIdentityPayload;\n}\n</code></pre> <p>This approach:</p> <ul> <li>Preserves simplicity: Servers just validate and forward</li> <li>Enables multi-tenancy: One instance, multiple users</li> <li>Aligns with enterprise patterns: Tokens from central identity</li> <li>Supports all environments: Works without browsers or internet</li> <li>Maintains security: Full validation without OAuth complexity</li> </ul> <p>(A detailed technical proposal explores the complete specification, including session-level patterns and implementation guidance.)</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#the-broader-pattern","title":"The Broader Pattern","text":"<p>This situation reflects a recurring challenge in protocol design: the tension between theoretical purity and operational reality.</p> <p>MCP's core protocol succeeds because it embraces simplicity. The authentication challenges arise where that principle gives way to prescriptive security guidance that doesn't align with how systems actually work.</p> <p>When official implementations unanimously diverge from stated best practices, it suggests the practices\u2014not the implementations\u2014need reconsideration.</p>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#moving-forward","title":"Moving Forward","text":"<p>MCP has tremendous potential to standardise LLM-to-system integration. The protocol foundation is solid. The tools system is well-designed. But authentication needs pragmatic solutions that acknowledge:</p> <ol> <li>Enterprise networks have established patterns for identity propagation</li> <li>Multi-tenancy requires identity at the request level, not instance level</li> <li>Simplicity means not reimplementing OAuth in every server</li> <li>Security comes from proper validation, not architectural constraints</li> </ol>"},{"location":"2025/11/17/mcps-identity-crisis-when-security-theatre-meets-enterprise-reality/#a-question-worth-answering","title":"A Question Worth Answering","text":"<p>If MCP servers are trusted with user data but not with bearer tokens, what threat model justifies this distinction?</p> <p>And if the answer is \"defence in depth\"\u2014shouldn't we apply that principle by enabling secure patterns that people will actually use, rather than forcing complex ones they'll work around?</p> <p>The author is a Staff Engineer at Mozilla.ai, creator of mcpd, with extensive experience in enterprise authentication systems including work at HashiCorp on Vault and major financial institutions. This analysis is based on public specifications, official implementations, and established industry patterns.</p>"},{"location":"archive/2025/","title":"2025","text":""},{"location":"category/architecture/","title":"Architecture","text":""},{"location":"category/identity/","title":"Identity","text":""},{"location":"category/mcp/","title":"MCP","text":""}]}